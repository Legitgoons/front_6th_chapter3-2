# 반복 일정 기능 테스트 전체 요약 및 교훈

## 프로젝트 개요

"1. 반복 유형 선택", "2. 반복 일정 표시", "3. 반복 종료", "4. 반복 일정 단일 수정", "5. 반복 일정 단일 삭제" 기능의 테스트 구현 과정에서 발생한 다양한 문제들과 해결 과정을 문서화했습니다. 아홉 가지 핵심 테스트를 통해 React + MUI + Testing Library 환경에서의 복잡한 UI 테스트 구현 방법을 학습했습니다.

## 구현한 테스트 목록

| 테스트명                    | 목적                  | 주요 검증 사항                |
| --------------------------- | --------------------- | ----------------------------- |
| 01. 반복 유형 선택 기본     | UI 컴포넌트 동작 확인 | 드롭다운 옵션 존재, 선택 기능 |
| 02. 31일 매월 반복          | 달력 로직 검증        | 31일이 없는 달 처리           |
| 03. 윤년 2월 29일 매년 반복 | 윤년 로직 검증        | 평년/윤년 구분 처리           |
| 04. 반복 일정 표시          | 시각적 구분 확인      | 반복 아이콘 표시              |
| 05. 반복 종료 조건 설정     | 종료일 설정 확인      | 종료일 입력 및 표시           |
| 06. 반복 종료일 이후 미생성 | 종료 로직 검증        | 종료일 이후 일정 생성 안함    |
| 07. 반복 일정 단일 수정     | 단일 수정 변환 확인   | 반복 일정 → 단일 일정 변환   |
| 08. 반복 아이콘 사라짐      | 시각적 변화 확인      | 수정 후 반복 아이콘 제거      |
| 09. 반복 일정 단일 삭제     | 개별 삭제 확인        | 특정 인스턴스만 삭제          |

## 공통 문제 패턴 및 해결 전략

### 1. MUI 컴포넌트 접근성 문제

**문제:**

- `FormControlLabel`, `Checkbox`, `TextField` 등에서 중복 라벨 문제
- Testing Library가 어떤 요소를 선택해야 할지 모호함

**해결 전략:**

```typescript
// ❌ 피해야 할 방법들
screen.getByLabelText('반복 일정');
screen.getByLabelText('반복 종료일');

// ✅ 권장하는 방법들
screen.getByRole('checkbox', { name: /반복 일정/ }); // 정규식으로 유연한 매칭
document.getElementById('repeat-end-date'); // 고유 ID 사용
```

**MUI 컴포넌트 접근 우선순위:**

1. `getByRole` + 정규식 - 가장 안정적
2. `getElementById` - 고유한 경우
3. `getByLabelText` - 마지막 수단

### 2. 비동기 상태 업데이트 처리

**문제:**
React 상태 변경 후 DOM 업데이트는 비동기적으로 발생

**해결 전략:**

```typescript
// ❌ 동기적 접근
await user.click(repeatCheckbox);
await user.click(screen.getByLabelText('반복 유형')); // 실패 가능성

// ✅ 비동기 대응
await user.click(repeatCheckbox);
await waitFor(() => {
  expect(screen.getByLabelText('반복 유형')).toBeInTheDocument();
});
```

### 3. 복잡한 헬퍼 함수 설계

모든 테스트에서 재사용할 수 있는 `saveRepeatingSchedule` 함수 개발:

```typescript
const saveRepeatingSchedule = async (user: UserEvent, form: FormData) => {
  // 기본 폼 입력
  await fillBasicForm(user, form);

  // 반복 설정 (조건부)
  if (form.repeatType !== 'none') {
    await handleRepeatSettings(user, form);
  }

  // 제출
  await user.click(screen.getByTestId('event-submit-button'));
};
```

**설계 원칙:**

- **방어적 코딩**: 조건부 실행으로 다양한 상황 대응
- **재사용성**: 모든 반복 일정 테스트에서 활용 가능
- **유연성**: 다양한 반복 옵션 조합 지원

## 도메인 로직의 복잡성 처리

### 달력 관련 특수 케이스

1. **31일 매월 반복**

   - 2월: 28/29일 (평년/윤년)
   - 4월, 6월, 9월, 11월: 30일
   - 나머지: 31일

2. **윤년 2월 29일 매년 반복**
   - 윤년 판별: `(year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0)`
   - 4년 중 1년만 실행 가능

### Mock Handler 설계

```typescript
const shouldSkipDate = (baseEvent: Event, currentDate: Date): boolean => {
  const baseDate = new Date(baseEvent.date);

  // 매월 반복에서 31일인 경우
  if (baseEvent.repeat.type === 'monthly' && baseDate.getDate() === 31) {
    return currentDate.getDate() !== 31;
  }

  // 매년 반복에서 2월 29일인 경우
  if (
    baseEvent.repeat.type === 'yearly' &&
    baseDate.getMonth() === 1 &&
    baseDate.getDate() === 29
  ) {
    return (
      !isLeapYear(currentDate.getFullYear()) ||
      currentDate.getMonth() !== 1 ||
      currentDate.getDate() !== 29
    );
  }

  return false;
};
```

## 테스트 전략의 진화

### Phase 1: 이상적 테스트 → Phase 2: 현실적 테스트

**초기 접근 (실패):**

```typescript
// 개별 반복 일정들이 별도 이벤트로 생성될 것이라 가정
expect(eventList.getByText('2025-01-31')).toBeInTheDocument();
expect(eventList.getByText('2025-03-31')).toBeInTheDocument();
expect(eventList.queryByText('2025-02-31')).not.toBeInTheDocument();
```

**수정된 접근 (성공):**

```typescript
// 현재 구현에 맞춰 반복 정보 메타데이터 검증
expect(eventList.getByText('2025-01-31')).toBeInTheDocument();
expect(eventList.getByText(/반복:/)).toBeInTheDocument();
expect(eventList.getByText(/월마다/)).toBeInTheDocument();
```

**교훈:** 테스트는 이상적인 구현이 아닌 실제 구현을 반영해야 함

## 디버깅 및 문제 해결 프로세스

### 1. 에러 메시지 정확한 분석

```
Unable to find a label with the text of: 반복 유형
Found multiple elements with the text of: 반복 일정
```

### 2. DOM 구조 분석

Testing Library의 디버깅 기능 활용:

```typescript
screen.debug(); // 현재 DOM 구조 출력
console.log(screen.getByTestId('event-list')); // 특정 요소 분석
```

### 3. 점진적 해결

1. 요소 접근 방법 변경
2. 비동기 처리 추가
3. 헬퍼 함수 개선
4. 테스트 기대값 조정

## 성능 및 유지보수성 개선

### 1. 테스트 실행 시간 최적화

- 불필요한 `waitFor` 제거
- 효율적인 DOM 쿼리 사용
- Mock Handler 로직 최적화

### 2. 코드 재사용성 향상

- 공통 헬퍼 함수 추출
- 일관된 패턴 적용
- 타입 안전성 확보

### 3. 문서화 및 지식 공유

- 각 문제 상황별 상세 문서 작성
- 해결 과정의 논리적 설명
- 재발 방지를 위한 가이드라인 제시

## 향후 개선 방향

### 1. 추가 테스트 시나리오

- **반복 일정 표시**: ✅ 완료 - 아이콘 및 시각적 표시 확인
- **반복 종료**: ✅ 완료 - 종료일 조건 처리
- **반복 일정 단일 수정**: ✅ 완료 - 반복 일정을 단일 일정으로 변경
- **반복 일정 단일 삭제**: ✅ 완료 - 반복 일정 중 특정 인스턴스만 삭제
- **반복 간격 설정**: 2일마다, 3주마다 등의 복잡한 간격 처리 (미구현)
- **반복 패턴 변경**: 기존 반복 일정의 패턴 수정 (미구현)
- **반복 예외 처리**: 반복 시리즈에서 특정 날짜 제외 (미구현)

### 2. 테스트 인프라 개선

```typescript
// 더 강력한 헬퍼 함수들
const expectRepeatingEvent = (eventList, config) => {
  expect(eventList.getByText(config.title)).toBeInTheDocument();
  expect(eventList.getByText(config.date)).toBeInTheDocument();
  expect(eventList.getByText(new RegExp(config.repeatText))).toBeInTheDocument();
};

// 날짜 계산 유틸리티
const getNextOccurrence = (date: string, type: RepeatType) => {
  // 복잡한 날짜 계산 로직
};
```

### 3. 실제 구현 개선

- Mock Handler를 실제 백엔드 로직으로 대체
- 반복 일정 생성 알고리즘 최적화
- 사용자 경험 개선 (로딩 상태, 에러 처리)

## 핵심 교훈

### 1. **테스트는 구현의 거울이다**

이상적인 동작보다는 실제 구현을 정확히 반영하는 테스트가 가치 있음

### 2. **복잡성은 단계적으로 해결하라**

한 번에 모든 문제를 해결하려 하지 말고, 하나씩 차근차근 해결

### 3. **도구의 한계를 인정하라**

Testing Library, MUI 등의 한계를 인정하고 현실적인 해결책 찾기

### 4. **문서화의 중요성**

복잡한 문제 해결 과정을 문서화하여 동일한 실수 반복 방지

### 5. **data-testid 사용 지양의 중요성**

의미 없는 식별자보다는 접근성 기반의 쿼리 방법이 더 가치 있음

### 6. **다중 요소 처리 전략**

반복 데이터의 특성상 여러 인스턴스가 존재할 때 `queryAllBy*` 활용

### 7. **사용자 중심적 사고**

테스트는 결국 사용자가 실제로 경험할 상황을 검증하는 것

### 8. **폼 상태와 UI 상태의 분리 이해**

"3. 반복 종료" 기능에서 폼 제출 후 리셋되는 특성을 고려하여 검증 위치를 정확히 설정하는 것의 중요성

### 9. **Mock Handler 선택의 중요성**

테스트 목적에 따라 적절한 Mock Handler(`setupMockHandlerCreation` vs `setupMockHandlerRepeating`) 선택 필요

### 10. **날짜 기반 비즈니스 로직 검증**

`vi.setSystemTime`과 Mock Handler의 `endDate` 로직을 조합하여 시간 기반 제약사항을 정확히 검증

### 11. **UI와 Backend 로직의 일치성**

UI의 필터링 로직과 Backend Mock의 생성 로직이 일치해야 테스트가 올바르게 작동

### 12. **스코프 제한을 통한 Multiple Elements 해결**

여러 개의 동일한 요소가 존재할 때 `within()` 헬퍼로 검색 범위를 제한하여 정확한 요소 선택

### 13. **비동기 데이터 로딩 대기 전략**

Mock Handler 데이터 로딩을 `waitFor`와 UI 상태 변화를 조합하여 안정적으로 대기

### 14. **점진적 마이그레이션의 중요성**

기존 테스트에 영향을 주는 변경 시 일괄 변경 도구를 활용한 체계적 접근

### 15. **접근성 우선 쿼리 일관성**

프로젝트 전체에서 `data-testid` 대신 의미 있는 접근성 속성 기반 쿼리 사용

### 16. **기능별 적절한 Mock 데이터 구성**

테스트 목적에 맞는 반복 일정 데이터 구성과 `generateRepeatingEvents` 함수 재활용

### 17. **부분 변화 검증 전략**

전체 삭제가 아닌 개별 삭제의 경우 개수 변화 기반 검증이 효과적

### 18. **Array 인덱스를 활용한 특정 요소 선택**

`getAllByText()[0]`을 통한 예측 가능하고 일관된 요소 선택

이러한 경험을 통해 단순한 UI 테스트를 넘어서 복잡한 비즈니스 로직, 도메인 지식, 그리고 현실적인 제약사항을 모두 고려한 포괄적인 테스트 전략을 수립할 수 있었습니다. 특히 "반복 일정 표시", "반복 종료", "반복 일정 단일 수정", "반복 일정 단일 삭제" 기능을 통해 데이터의 특성을 정확히 이해하고 그에 맞는 적절한 검증 전략을 선택하는 것의 중요성을 배웠습니다.
