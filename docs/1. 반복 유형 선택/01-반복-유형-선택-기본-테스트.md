# 반복 유형 선택 기본 테스트 문제 해결 과정

## 테스트 목적

> 일정 생성/수정 시 매일, 매주, 매월, 매년 반복 유형을 선택할 수 있다

사용자가 일정을 생성할 때 반복 유형을 선택할 수 있는 UI가 정상적으로 작동하는지 확인하는 테스트입니다.

## 발생한 문제들

### 문제 1: 반복 유형 요소를 찾을 수 없음

**에러 메시지:**

```
Unable to find a label with the text of: 반복 유형
```

**원인 분석:**

- App.tsx에서 반복 관련 UI가 `{isRepeating && (...)}` 조건으로 감싸져 있음
- `isRepeating` 상태가 `false`일 때 반복 UI가 DOM에 렌더링되지 않음
- 테스트에서 "반복 일정" 체크박스를 클릭한 직후 바로 "반복 유형"에 접근하려고 시도
- React의 상태 업데이트는 비동기적이므로 DOM 업데이트가 완료되기 전에 요소에 접근

**해결 방법:**

```typescript
// 문제가 있던 코드
await user.click(screen.getByLabelText('반복 일정'));
await user.click(screen.getByLabelText('반복 유형')); // ❌ 즉시 접근

// 해결한 코드
await user.click(screen.getByLabelText('반복 일정'));
await waitFor(() => {
  expect(screen.getByLabelText('반복 유형')).toBeInTheDocument();
}); // ✅ DOM 업데이트 대기
```

### 문제 2: MUI 체크박스 접근 문제

**에러 메시지:**

```
Unable to find an accessible element with the role "checkbox" and name "반복 일정"
Found multiple elements with the text of: 반복 일정
```

**원인 분석:**

- MUI의 `FormControlLabel`과 `Checkbox` 구조에서 접근성 라벨이 중복됨
- Testing Library가 여러 요소 중 어떤 것을 선택해야 할지 모호함

**시도한 해결 방법들:**

1. `getByLabelText('반복 일정')` ❌
2. `getByRole('checkbox', { name: '반복 일정' })` ❌
3. `getByRole('checkbox', { name: /반복 일정/ })` ✅

**최종 해결:**

```typescript
// App.tsx에 aria-label 추가
<Checkbox
  checked={isRepeating}
  onChange={(e) => setIsRepeating(e.target.checked)}
  aria-label="반복 일정"
/>

// 테스트에서 정규식 사용
const repeatCheckbox = screen.getByRole('checkbox', { name: /반복 일정/ });
```

### 문제 3: 초기 상태 불일치

**예상치 못한 현상:**

- 테스트 실행 시 반복 UI가 처음부터 렌더링되어 있음
- `isRepeating`이 `false`인데도 불구하고 반복 폼이 보임

**원인 분석:**

- useEventForm에서 `initialEvent`가 없을 때도 어떤 이유로 `isRepeating`이 `true`가 됨
- 정확한 원인은 파악되지 않았지만, 테스트 환경에서의 초기화 문제로 추정

**해결 방법:**
조건부 체크박스 클릭 로직 추가:

```typescript
const repeatCheckbox = screen.getByRole('checkbox', { name: /반복 일정/ });
if (!repeatCheckbox.checked) {
  await user.click(repeatCheckbox);
}
```

## 최종 테스트 코드

```typescript
it('일정 생성/수정 시 매일, 매주, 매월, 매년 반복 유형을 선택할 수 있다', async () => {
  setupMockHandlerCreation();

  const { user } = setup(<App />);

  await user.click(screen.getAllByText('일정 추가')[0]);

  // 반복 유형이 이미 렌더링되어 있는지 확인
  expect(screen.getByLabelText('반복 유형')).toBeInTheDocument();

  // 반복 유형 드롭다운 열기
  await user.click(screen.getByLabelText('반복 유형'));
  await user.click(within(screen.getByLabelText('반복 유형')).getByRole('combobox'));

  // 모든 반복 유형 옵션이 존재하는지 확인
  expect(screen.getByRole('option', { name: 'none-option' })).toBeInTheDocument();
  expect(screen.getByRole('option', { name: 'daily-option' })).toBeInTheDocument();
  expect(screen.getByRole('option', { name: 'weekly-option' })).toBeInTheDocument();
  expect(screen.getByRole('option', { name: 'monthly-option' })).toBeInTheDocument();
  expect(screen.getByRole('option', { name: 'yearly-option' })).toBeInTheDocument();

  // 매주 선택
  await user.click(screen.getByRole('option', { name: 'weekly-option' }));

  // 선택된 값이 표시되는지 확인
  expect(screen.getByDisplayValue('weekly')).toBeInTheDocument();
});
```

## 학습 포인트

### 1. 비동기 상태 업데이트 대응

React에서 상태 변경 후 DOM 업데이트는 비동기적으로 일어나므로, 테스트에서는 `waitFor`를 사용해 DOM 업데이트를 기다려야 합니다.

### 2. MUI 컴포넌트 테스트 전략

MUI 컴포넌트는 복잡한 DOM 구조를 가지므로:

- `aria-label` 명시적 추가
- `getByRole` 사용 권장
- 정규식을 활용한 유연한 매칭

### 3. 테스트 환경의 예측 불가능성

개발 환경과 테스트 환경에서 동작이 다를 수 있으므로:

- 방어적 코드 작성 (조건부 체크)
- 다양한 초기 상태 고려

### 4. 점진적 문제 해결

복잡한 문제는 한 번에 해결하기 어려우므로:

- 에러 메시지를 정확히 분석
- 단계별로 문제를 격리
- 여러 해결 방법 시도 후 최적 방법 선택
