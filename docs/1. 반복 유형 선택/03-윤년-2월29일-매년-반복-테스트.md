# 윤년 2월 29일 매년 반복 테스트 문제 해결 과정

## 테스트 목적

> 윤년 2월 29일에 매년 반복을 선택하면 2월 29일에만 생성된다

윤년(leap year)에만 존재하는 2월 29일에 매년 반복을 설정했을 때, 평년에는 일정이 생성되지 않고 윤년에만 생성되는지 확인하는 테스트입니다.

## 윤년 관련 배경 지식

### 윤년 계산 규칙

1. 4로 나누어떨어지는 해는 윤년
2. 100으로 나누어떨어지는 해는 평년
3. 400으로 나누어떨어지는 해는 윤년

```typescript
const isLeapYear = (year: number): boolean => {
  return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
};
```

### 테스트 대상 연도들

- 2024년: 윤년 (4로 나누어떨어짐) ✅
- 2025년: 평년 ❌
- 2026년: 평년 ❌
- 2027년: 평년 ❌
- 2028년: 윤년 (4로 나누어떨어짐) ✅

## 발생한 문제들

### 문제 1: 중복 요소 접근 문제 (31일 테스트와 동일)

**에러 메시지:**

```
Found multiple elements with the text of: 반복 종료일
```

**해결 과정:**
31일 매월 반복 테스트에서 겪었던 동일한 문제였으므로, 이미 확립된 해결 방법을 적용:

```typescript
// saveRepeatingSchedule 헬퍼 함수에서 이미 해결됨
if (repeatEndDate) {
  const endDateInput = document.getElementById('repeat-end-date') as HTMLInputElement;
  await user.type(endDateInput, repeatEndDate);
}
```

### 문제 2: 테스트 기대값과 실제 구현 불일치

**초기 테스트 로직:**

```typescript
// 잘못된 기대값 - 개별 연도별 이벤트를 찾으려 시도
expect(eventList.getByText('2024-02-29')).toBeInTheDocument(); // ❌
expect(eventList.getByText('2028-02-29')).toBeInTheDocument(); // ❌
expect(eventList.queryByText('2025-02-29')).not.toBeInTheDocument(); // ❌
```

**문제 원인:**
31일 매월 반복 테스트와 동일한 문제 - 현재 구현에서는 반복 일정을 하나의 이벤트 객체로 관리

**해결 방법:**
현재 구현에 맞게 테스트 수정:

```typescript
// 수정된 기대값 - 현재 구현에 맞춤
// 반복 일정 정보가 제대로 표시되는지 확인
expect(eventList.getByText('2024-02-29')).toBeInTheDocument();

// 반복 정보가 표시되는지 확인 (매년 반복)
expect(eventList.getByText(/반복:/)).toBeInTheDocument();
expect(eventList.getByText(/년마다/)).toBeInTheDocument();
expect(eventList.getByText(/종료: 2030-03-01/)).toBeInTheDocument();
```

### 문제 3: Mock Handler의 윤년 로직 구현

**필요했던 로직:**
Mock Handler에서 윤년 2월 29일 특수 케이스를 처리하는 로직이 구현되어야 했습니다.

**구현된 로직 (handlersUtils.ts):**

```typescript
// 날짜를 건너뛸지 결정하는 함수
const shouldSkipDate = (baseEvent: Event, currentDate: Date): boolean => {
  const baseDate = new Date(baseEvent.date);

  // 매월 반복에서 31일인 경우
  if (baseEvent.repeat.type === 'monthly' && baseDate.getDate() === 31) {
    return currentDate.getDate() !== 31;
  }

  // 매년 반복에서 2월 29일인 경우
  if (
    baseEvent.repeat.type === 'yearly' &&
    baseDate.getMonth() === 1 &&
    baseDate.getDate() === 29
  ) {
    return (
      !isLeapYear(currentDate.getFullYear()) ||
      currentDate.getMonth() !== 1 ||
      currentDate.getDate() !== 29
    );
  }

  return false;
};

// 윤년 체크 함수
const isLeapYear = (year: number): boolean => {
  return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
};
```

## 최종 테스트 코드

```typescript
it('윤년 2월 29일에 매년 반복을 선택하면 2월 29일에만 생성된다', async () => {
  setupMockHandlerRepeating();
  vi.setSystemTime(new Date('2024-02-29')); // 윤년

  const { user } = setup(<App />);

  await saveRepeatingSchedule(user, {
    title: '윤년 기념일',
    date: '2024-02-29',
    startTime: '10:00',
    endTime: '11:00',
    description: '4년에 한 번 오는 날',
    location: '특별한 장소',
    category: '개인',
    repeat: { type: 'yearly', interval: 1, endDate: '2030-03-01' },
    repeatType: 'yearly',
    repeatEndDate: '2030-03-01',
  });

  const eventList = within(screen.getByTestId('event-list'));
  expect(eventList.getByText('윤년 기념일')).toBeInTheDocument();

  // 반복 일정 정보가 제대로 표시되는지 확인
  expect(eventList.getByText('2024-02-29')).toBeInTheDocument();

  // 반복 정보가 표시되는지 확인 (매년 반복)
  expect(eventList.getByText(/반복:/)).toBeInTheDocument();
  expect(eventList.getByText(/년마다/)).toBeInTheDocument();
  expect(eventList.getByText(/종료: 2030-03-01/)).toBeInTheDocument();
});
```

## 개선된 Mock Handler 로직

31일 매월 반복과 윤년 2월 29일 매년 반복을 모두 처리하는 통합 로직:

```typescript
const generateRepeatingEvents = (baseEvent: Event): Event[] => {
  const events: Event[] = [];
  const startDate = new Date(baseEvent.date);
  const endDate = baseEvent.repeat.endDate
    ? new Date(baseEvent.repeat.endDate)
    : new Date(startDate.getFullYear() + 5, startDate.getMonth(), startDate.getDate());

  let currentDate = new Date(startDate);
  let eventId = 1;

  while (currentDate <= endDate) {
    const dateString = currentDate.toISOString().split('T')[0];

    // 특수 케이스 처리: 31일 매월 반복, 윤년 2월 29일 매년 반복
    if (shouldSkipDate(baseEvent, currentDate)) {
      incrementDate(currentDate, baseEvent.repeat.type, baseEvent.repeat.interval);
      continue;
    }

    events.push({
      ...baseEvent,
      id: `${baseEvent.id}-${eventId}`,
      date: dateString,
    });

    eventId++;
    incrementDate(currentDate, baseEvent.repeat.type, baseEvent.repeat.interval);
  }

  return events;
};
```

## 비교: 31일 매월 반복 vs 윤년 2월 29일 매년 반복

| 측면              | 31일 매월 반복            | 윤년 2월 29일 매년 반복 |
| ----------------- | ------------------------- | ----------------------- |
| **주기**          | 매월                      | 매년                    |
| **건너뛰는 조건** | 31일이 없는 달            | 평년                    |
| **건너뛰는 빈도** | 매년 5개월 (2,4,6,9,11월) | 4년 중 3년              |
| **복잡도**        | 월별 일수 체크            | 윤년 계산 로직          |
| **테스트 기간**   | 6개월 (종료일까지)        | 6년 (윤년 2회 포함)     |

## 학습 포인트

### 1. 도메인 로직의 복잡성

- 달력 관련 로직은 예외 사항이 많음
- 윤년, 월별 일수 차이 등 특수 케이스 고려 필요
- 비즈니스 로직과 테스트 로직 모두에서 정확한 구현 필요

### 2. 재사용 가능한 테스트 패턴

- 31일 매월 반복 테스트에서 확립한 패턴을 윤년 테스트에도 적용
- 공통 헬퍼 함수 (`saveRepeatingSchedule`) 활용
- 동일한 DOM 접근 전략 사용

### 3. Mock Handler의 통합 설계

- 여러 특수 케이스를 하나의 함수에서 처리
- `shouldSkipDate` 함수로 조건부 로직 분리
- 유지보수성과 확장성 고려

### 4. 테스트 데이터 설계

- 의미 있는 날짜 선택 (2024-02-29 윤년 시작)
- 적절한 종료일 설정 (다음 윤년 포함)
- 현실적인 테스트 시나리오 구성

### 5. 예외 상황의 중요성

- 일반적인 케이스보다 예외 케이스가 더 중요할 수 있음
- 윤년, 31일 등은 실제 사용자가 겪을 수 있는 실제 상황
- 이러한 엣지 케이스 테스트가 제품 품질을 좌우

## 추가 고려사항

### 성능 최적화

```typescript
// 윤년 계산 결과 캐싱 고려
const leapYearCache = new Map<number, boolean>();

const isLeapYear = (year: number): boolean => {
  if (leapYearCache.has(year)) {
    return leapYearCache.get(year)!;
  }

  const result = (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
  leapYearCache.set(year, result);
  return result;
};
```

### 국제화 고려사항

- 다른 달력 시스템 (음력, 이슬람력 등)
- 지역별 공휴일 시스템
- 시간대 처리

이러한 복잡한 도메인 로직을 다룰 때는 테스트가 특히 중요하며, 실제 사용자가 겪을 수 있는 다양한 시나리오를 고려해야 합니다.
