# 반복 일정 표시 테스트 문제 해결 과정

## 테스트 목적

> 캘린더 뷰에서 반복 일정은 아이콘으로 표시된다

반복 일정으로 설정된 이벤트가 이벤트 리스트에서 반복 아이콘을 통해 시각적으로 구분되는지 확인하는 테스트입니다.

## 발생한 문제들

### 문제 1: data-testid 사용 지양 요청

**초기 접근:**
사용자가 `data-testid` 사용을 자제해달라고 요청했습니다.

**원인 분석:**

- `data-testid`는 의미 없는 식별자로 간주
- 더 의미 있는 접근성 기반 쿼리 방법이 선호됨

**해결 방법:**

```typescript
// ❌ data-testid 사용 방식
expect(within(eventContainer as HTMLElement).getByTestId('repeat-icon')).toBeInTheDocument();

// ✅ aria-label 사용 방식
expect(within(eventContainer as HTMLElement).getByLabelText('반복 일정')).toBeInTheDocument();
```

### 문제 2: Mock Handler 선택 문제

**초기 테스트 코드:**

```typescript
setupMockHandlerCreation(); // ❌ 반복 로직 없음
```

**수정된 코드:**

```typescript
setupMockHandlerRepeating(); // ✅ 반복 일정 전용 handler
```

**이유:**

- `setupMockHandlerCreation()`은 단일 일정만 처리
- `setupMockHandlerRepeating()`은 반복 일정의 여러 인스턴스를 생성하는 로직 포함

### 문제 3: 여러 반복 아이콘 중복 문제

**에러 메시지:**

```
Found multiple elements with the text of: 반복 일정
```

**원인 분석:**
`setupMockHandlerRepeating()`이 매일 반복 일정을 생성할 때 여러 개의 이벤트 인스턴스를 만들어 각각에 반복 아이콘이 표시됨:

```html
<!-- 첫 번째 인스턴스 -->
<svg aria-label="반복 일정" data-testid="RepeatIcon">...</svg>

<!-- 두 번째 인스턴스 -->
<svg aria-label="반복 일정" data-testid="RepeatIcon">...</svg>

<!-- ... 여러 개 더 -->
```

**시도한 해결 방법들:**

1. **DOM 구조 기반 접근 (실패)**:

```typescript
// ❌ 복잡하고 불안정한 방법
const eventContainer = eventList.getByText('일일 스탠드업').closest('div[style*="border"]');
expect(within(eventContainer as HTMLElement).getByLabelText('반복 일정')).toBeInTheDocument();
```

2. **단일 요소 접근 (실패)**:

```typescript
// ❌ 여러 요소 중 하나를 선택할 수 없음
expect(eventList.getByLabelText('반복 일정')).toBeInTheDocument();
```

3. **최종 해결 방법 (성공)**:

```typescript
// ✅ 여러 요소의 존재를 확인
const repeatIcons = eventList.queryAllByLabelText('반복 일정');
expect(repeatIcons.length).toBeGreaterThan(0);
```

### 문제 4: DOM 구조 접근의 복잡성

**DOM 구조 분석:**

```html
<div data-testid="event-list">
  <div class="MuiBox-root css-jtjz5h">
    <!-- 첫 번째 이벤트 -->
    <div class="MuiStack-root css-gmwslw-MuiStack-root">
      <div class="MuiStack-root css-nen11g-MuiStack-root">
        <div class="MuiStack-root css-kdc3n8-MuiStack-root">
          <svg aria-label="반복 일정" data-testid="RepeatIcon">...</svg>
          <p>일일 스탠드업</p>
        </div>
        <!-- 기타 이벤트 정보 -->
      </div>
    </div>
  </div>
  <!-- 더 많은 반복 이벤트 인스턴스들... -->
</div>
```

**학습된 교훈:**

- 복잡한 DOM 구조에서 특정 요소에 접근하는 것보다는 전체적인 기능 검증이 더 안정적
- 반복 일정의 특성상 여러 인스턴스가 생성되는 것은 정상적인 동작

## 구현 과정

### 1. MUI 아이콘 추가

```typescript
// App.tsx - import 추가
import {
  Notifications,
  ChevronLeft,
  ChevronRight,
  Delete,
  Edit,
  Close,
  Repeat, // ✅ 추가
} from '@mui/icons-material';
```

### 2. 조건부 반복 아이콘 렌더링

```typescript
// App.tsx - 이벤트 리스트에서
<Stack direction="row" spacing={1} alignItems="center">
  {notifiedEvents.includes(event.id) && <Notifications color="error" />}
  {event.repeat.type !== 'none' && (
    <Repeat aria-label="반복 일정" fontSize="small" />
  )}
  <Typography>{event.title}</Typography>
</Stack>
```

**구현 포인트:**

- `event.repeat.type !== 'none'` 조건으로 반복 일정만 아이콘 표시
- `aria-label="반복 일정"`으로 접근성 확보
- `fontSize="small"`로 적절한 크기 조정

### 3. 최종 테스트 코드

```typescript
it('캘린더 뷰에서 반복 일정은 아이콘으로 표시된다', async () => {
  setupMockHandlerRepeating(); // 반복 일정 전용 handler

  const { user } = setup(<App />);

  await saveRepeatingSchedule(user, {
    title: '일일 스탠드업',
    date: '2025-10-15',
    startTime: '09:00',
    endTime: '09:30',
    description: '매일 진행되는 스탠드업 미팅',
    location: '회의실 B',
    category: '업무',
    repeat: { type: 'daily', interval: 1 },
    repeatType: 'daily',
  });

  const eventList = within(screen.getByTestId('event-list'));

  // 반복 아이콘이 표시되는지 확인 (반복 일정에 존재)
  const repeatIcons = eventList.queryAllByLabelText('반복 일정');
  expect(repeatIcons.length).toBeGreaterThan(0);

  // 일일 스탠드업 이벤트가 생성되었는지 확인
  expect(eventList.getAllByText('일일 스탠드업').length).toBeGreaterThan(0);
});
```

## 학습 포인트

### 1. 의미 있는 테스트 쿼리 전략

**우선순위:**

1. `getByRole` - 가장 의미 있는 접근
2. `getByLabelText` - 접근성 기반
3. `queryAllBy*` 변형 - 여러 요소 처리
4. `data-testid` - 최후 수단

### 2. Mock Handler 특성 이해

**반복 일정의 특수성:**

- `setupMockHandlerRepeating()`은 반복 규칙에 따라 여러 이벤트 인스턴스 생성
- 매일 반복 → 여러 날짜의 동일한 이벤트들
- 각 인스턴스마다 개별 반복 아이콘 존재

### 3. 테스트 설계 철학

**단일 vs 다중 요소 검증:**

```typescript
// ❌ 정확히 하나의 요소만 찾으려 시도
expect(eventList.getByLabelText('반복 일정')).toBeInTheDocument();

// ✅ 요소의 존재 여부만 확인
expect(eventList.queryAllByLabelText('반복 일정').length).toBeGreaterThan(0);
```

**교훈:**

- 반복 일정의 본질상 여러 인스턴스가 존재하는 것이 정상
- 특정 개수보다는 "존재 여부"에 집중하는 것이 더 안정적

### 4. 실용적 접근성

**aria-label 활용:**

```typescript
<Repeat aria-label="반복 일정" fontSize="small" />
```

**장점:**

- 스크린 리더 지원
- 테스트에서 명확한 식별자 역할
- `data-testid`보다 의미 있는 접근

### 5. 점진적 문제 해결

**해결 과정:**

1. **요구사항 이해** → `data-testid` 사용 지양
2. **Mock Handler 교체** → 반복 일정 전용으로 변경
3. **DOM 구조 분석** → 여러 인스턴스 존재 파악
4. **쿼리 전략 변경** → `queryAllBy*` 사용

## 비교: 이전 테스트들과의 차이점

| 측면             | 반복 유형 선택 테스트       | 반복 일정 표시 테스트       |
| ---------------- | --------------------------- | --------------------------- |
| **복잡도**       | 단일 UI 상호작용            | 여러 인스턴스 처리          |
| **Mock Handler** | `setupMockHandlerRepeating` | `setupMockHandlerRepeating` |
| **검증 방식**    | 개별 옵션 존재 확인         | 아이콘 존재 여부 확인       |
| **DOM 접근**     | 직접적 요소 접근            | 다중 요소 배열 접근         |
| **주요 도전**    | 비동기 상태 업데이트        | 여러 요소 중복              |

## 추가 고려사항

### 1. 성능 최적화

현재 구현에서 모든 반복 이벤트에 개별 아이콘이 렌더링됩니다. 대량의 반복 일정이 있을 경우 최적화 고려 필요:

```typescript
// 가능한 최적화 방안
const RepeatIcon = React.memo(() => (
  <Repeat aria-label="반복 일정" fontSize="small" />
));
```

### 2. 다양한 반복 유형 표시

향후 반복 유형별로 다른 아이콘을 표시할 수 있음:

```typescript
const getRepeatIcon = (repeatType: RepeatType) => {
  switch (repeatType) {
    case 'daily': return <Today aria-label="매일 반복" fontSize="small" />;
    case 'weekly': return <DateRange aria-label="매주 반복" fontSize="small" />;
    case 'monthly': return <CalendarMonth aria-label="매월 반복" fontSize="small" />;
    case 'yearly': return <CalendarToday aria-label="매년 반복" fontSize="small" />;
    default: return <Repeat aria-label="반복 일정" fontSize="small" />;
  }
};
```

### 3. 접근성 개선

```typescript
<Repeat
  aria-label={`반복 일정 (${event.repeat.interval}${getRepeatUnit(event.repeat.type)}마다)`}
  fontSize="small"
/>
```

이러한 경험을 통해 복잡한 UI 상태를 테스트할 때는 데이터의 특성을 정확히 이해하고, 그에 맞는 적절한 검증 전략을 선택하는 것이 중요함을 배웠습니다.
