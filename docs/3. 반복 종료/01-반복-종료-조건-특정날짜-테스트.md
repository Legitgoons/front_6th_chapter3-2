# 반복 종료 조건으로 특정 날짜를 지정할 수 있다 - 테스트 구현 과정

## 테스트 목표

사용자가 반복 일정을 생성할 때 종료 날짜를 설정할 수 있는지 확인하는 테스트

## 발생한 문제들과 해결 과정

### 문제 1: Multiple elements 에러 - 반복 일정 체크박스

**에러 메시지:**

```
TestingLibraryElementError: Found multiple elements with the text of: 반복 일정
```

**원인:**

- `screen.getByLabelText('반복 일정')`이 `FormControlLabel`과 내부 `input` 엘리먼트를 동시에 찾음
- 반복 일정 기능을 위해 여러 요소가 동일한 라벨을 가지게 됨

**해결 방법:**

```typescript
// 변경 전
const repeatCheckbox = screen.getByLabelText('반복 일정');

// 변경 후
const repeatCheckbox = screen.getByRole('checkbox', { name: /반복 일정/ });
```

### 문제 2: Mock Handler 설정 문제

**문제:**

- `setupMockHandlerCreation()`을 사용했지만 반복 일정 생성 테스트에는 부적절
- 반복 일정 특성상 여러 인스턴스가 생성되어야 함

**해결 방법:**

```typescript
// 변경 전
setupMockHandlerCreation();

// 변경 후
setupMockHandlerRepeating();
```

### 문제 3: 비동기 DOM 업데이트 대기 문제

**에러 메시지:**

```
TestingLibraryElementError: Unable to find a label with the text of: 반복 유형
```

**원인:**

- 반복 일정 체크박스를 클릭한 후 반복 유형 선택 요소가 나타나기까지 시간이 걸림
- 테스트가 DOM 업데이트를 기다리지 않고 바로 요소를 찾으려 함

**해결 방법:**

```typescript
// 반복 유형 선택 요소가 나타날 때까지 대기
await waitFor(() => {
  expect(screen.getByLabelText('반복 유형')).toBeInTheDocument();
});
```

### 문제 4: 폼 리셋 후 값 확인 문제

**에러 메시지:**

```
TestingLibraryElementError: Unable to find an element with the display value: 2025-10-30.
```

**원인:**

- 일정 제출 후 폼이 리셋되어 `getByDisplayValue`로 폼 필드 값을 확인할 수 없음
- 실제로는 이벤트 리스트에 반복 종료 정보가 표시되어야 함

**해결 방법:**

```typescript
// 변경 전 - 폼 필드에서 값 확인
expect(screen.getByDisplayValue('2025-10-30')).toBeInTheDocument();

// 변경 후 - 이벤트 리스트에서 종료 날짜 확인
const eventList = within(screen.getByTestId('event-list'));
expect(eventList.getAllByText(/종료: 2025-10-30/).length).toBeGreaterThan(0);
```

## 최종 해결된 테스트 코드 구조

```typescript
test('반복 종료 조건으로 특정 날짜를 지정할 수 있다', async () => {
  setupMockHandlerRepeating(); // 올바른 Mock Handler 사용
  vi.setSystemTime(new Date('2025-10-15'));
  const { user } = setup(<App />);

  // 일정 추가 시작
  await user.click(screen.getAllByText('일정 추가')[0]);

  // 기본 정보 입력
  await user.type(screen.getByLabelText('제목'), '제한된 반복 일정');
  await user.type(screen.getByLabelText('날짜'), '2025-10-15');
  await user.type(screen.getByLabelText('시작 시간'), '14:00');
  await user.type(screen.getByLabelText('종료 시간'), '15:00');

  // 반복 일정 체크박스 활성화 (접근성 우선 쿼리 사용)
  const repeatCheckbox = screen.getByRole('checkbox', { name: /반복 일정/ });
  if (!repeatCheckbox.checked) {
    await user.click(repeatCheckbox);
  }

  // 반복 유형 선택 요소 대기
  await waitFor(() => {
    expect(screen.getByLabelText('반복 유형')).toBeInTheDocument();
  });

  // 반복 유형을 일일로 설정
  await user.click(screen.getByLabelText('반복 유형'));
  await user.click(within(screen.getByLabelText('반복 유형')).getByRole('combobox'));
  await user.click(screen.getByRole('option', { name: 'daily-option' }));

  // 반복 종료 날짜 설정
  const endDateInput = document.getElementById('repeat-end-date') as HTMLInputElement;
  await user.type(endDateInput, '2025-10-30');

  // 일정 제출
  await user.click(screen.getByTestId('event-submit-button'));

  // 이벤트 리스트에서 종료 날짜 확인 (폼 리셋 이후)
  const eventList = within(screen.getByTestId('event-list'));
  expect(eventList.getAllByText(/종료: 2025-10-30/).length).toBeGreaterThan(0);
});
```

## 핵심 교훈

1. **접근성 우선 쿼리 사용**: `getByRole`을 사용하여 multiple elements 문제 해결
2. **적절한 Mock Handler 선택**: 기능 특성에 맞는 mock 설정 중요
3. **비동기 DOM 업데이트 대기**: `waitFor` 사용으로 안정적인 테스트 작성
4. **UI 동작 이해**: 폼 리셋 등 실제 UI 동작을 고려한 어서션 작성
5. **테스트 검증 위치**: 데이터가 실제로 표시되는 위치에서 검증하기
