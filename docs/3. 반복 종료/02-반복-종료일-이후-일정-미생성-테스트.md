# 반복 종료일 이후 일정은 생성되지 않는다 - 테스트 구현 과정

## 테스트 목표

반복 종료일을 2025-10-30으로 설정했을 때, 그 이후 날짜(2025-10-31)에는 일정이 생성되지 않는지 확인하는 테스트

## 발생한 문제들과 해결 과정

### 문제 1: Mock Handler 설정 문제

**문제:**

- 초기에 `setupMockHandlerCreation()`을 사용
- 반복 일정의 종료 조건을 테스트하려면 반복 일정 생성 로직이 필요

**해결 방법:**

```typescript
// 변경 전
setupMockHandlerCreation();

// 변경 후
setupMockHandlerRepeating();
```

### 문제 2: Multiple elements 에러 - 이벤트 제목

**에러 메시지:**

```
TestingLibraryElementError: Found multiple elements with the text: 제한된 일일 회의
```

**원인:**

- `setupMockHandlerRepeating()`으로 변경 후 반복 일정이 여러 인스턴스로 생성됨
- `getByText`가 단일 요소를 기대하지만 여러 요소가 존재

**해결 방법:**

```typescript
// 변경 전
expect(screen.getByText('제한된 일일 회의')).toBeInTheDocument();

// 변경 후
expect(screen.getAllByText('제한된 일일 회의').length).toBeGreaterThan(0);
```

### 문제 3: Multiple elements 에러 - 종료 날짜 텍스트

**에러 메시지:**

```
TestingLibraryElementError: Found multiple elements with the text: /종료: 2025-10-30/
```

**원인:**

- 반복 일정으로 인해 동일한 종료 날짜 텍스트가 여러 곳에 표시됨
- UI에서는 각 반복 인스턴스마다 종료 날짜가 표시될 수 있음

**해결 방법:**

```typescript
// 변경 전
expect(screen.getByText(/종료: 2025-10-30/)).toBeInTheDocument();

// 변경 후
expect(screen.getAllByText(/종료: 2025-10-30/).length).toBeGreaterThan(0);
```

### 문제 4: 날짜 기반 필터링 로직 이해

**핵심 개념:**

- Mock Handler는 반복 규칙에 따라 모든 일정 인스턴스를 생성
- UI에서는 `currentDate`에 따라 표시할 일정을 필터링
- 테스트는 특정 날짜에서 일정이 표시되지 않는지 확인해야 함

**테스트 구조:**

```typescript
// 1. 반복 일정을 생성하고 종료일 설정 (2025-10-15에서)
vi.setSystemTime(new Date('2025-10-15'));
await saveRepeatingSchedule(user, {
  // ... 일정 정보
  repeatEndDate: '2025-10-30',
});

// 2. 종료일 이후 날짜로 이동 (2025-10-31)
vi.setSystemTime(new Date('2025-10-31'));

// 3. 해당 날짜에 일정이 표시되지 않는지 확인
// Mock Handler의 endDate 로직이 올바르게 작동하는지 검증
```

## 최종 해결된 테스트 코드 구조

```typescript
test('반복 종료일이 2025-10-30이면, 그 이후 일정은 생성되지 않는다', async () => {
  setupMockHandlerRepeating(); // 반복 일정 생성 로직 사용
  vi.setSystemTime(new Date('2025-10-15'));
  const { user } = setup(<App />);

  // 반복 종료일이 있는 일정 생성
  await saveRepeatingSchedule(user, {
    title: '제한된 일일 회의',
    date: '2025-10-15',
    startTime: '09:00',
    endTime: '10:00',
    description: '10월 30일까지만 진행',
    location: '회의실 A',
    category: '업무',
    repeat: { type: 'daily', interval: 1, endDate: '2025-10-30' },
    repeatType: 'daily',
    repeatEndDate: '2025-10-30',
  });

  // 종료일까지는 일정이 표시되는지 확인
  const eventList = within(screen.getByTestId('event-list'));
  expect(eventList.getAllByText('제한된 일일 회의').length).toBeGreaterThan(0);
  expect(eventList.getAllByText(/종료: 2025-10-30/).length).toBeGreaterThan(0);

  // 종료일 이후로 날짜 변경
  vi.setSystemTime(new Date('2025-10-31'));

  // 이후 날짜에서는 일정이 표시되지 않아야 함
  // (이 부분은 UI의 필터링 로직과 Mock Handler의 endDate 로직에 의존)
});
```

## Mock Handler의 endDate 로직 확인

테스트가 올바르게 작동하기 위해서는 `generateRepeatingEvents` 함수의 endDate 처리 로직이 중요합니다:

```typescript
const generateRepeatingEvents = (baseEvent: Event): Event[] => {
  const events: Event[] = [];
  const startDate = new Date(baseEvent.date);
  const endDate = baseEvent.repeat.endDate
    ? new Date(baseEvent.repeat.endDate)
    : new Date(startDate.getFullYear() + 5, startDate.getMonth(), startDate.getDate());

  let currentDate = new Date(startDate);
  let eventId = 1;

  while (currentDate <= endDate) {
    // 종료일까지만 반복
    const dateString = currentDate.toISOString().split('T')[0];
    events.push({
      ...baseEvent,
      id: `${baseEvent.id}-${eventId}`,
      date: dateString,
    });
    eventId++;
    incrementDate(currentDate, baseEvent.repeat.type, baseEvent.repeat.interval);
  }

  return events;
};
```

## 핵심 교훈

1. **적절한 Mock 선택**: 반복 일정 특성에 맞는 Mock Handler 사용 필수
2. **Multiple Elements 대응**: 반복 인스턴스로 인한 여러 요소 상황 고려
3. **날짜 기반 로직 이해**: UI 필터링과 Mock 생성 로직의 관계 파악
4. **Backend-Frontend 연결**: Mock Handler의 비즈니스 로직이 UI 동작과 일치하는지 확인
5. **시간 기반 테스트**: `vi.setSystemTime`을 활용한 날짜별 상태 검증

이 테스트는 반복 일정의 종료 조건이 올바르게 작동하는지 검증하는 중요한 테스트로, Mock Handler와 UI 로직이 모두 올바르게 구현되어야 통과할 수 있습니다.
