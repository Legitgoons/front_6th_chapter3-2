# 개별 삭제 후 상태 검증 전략

## 테스트 목표
반복 일정의 개별 인스턴스 삭제 후, 해당 인스턴스만 제거되고 다른 인스턴스들은 유지되는지 검증

## 검증 전략 선택의 중요성

### 반복 일정 삭제의 특수성
일반적인 일정 삭제와 달리 반복 일정의 개별 삭제는:
- **전체 삭제가 아님**: 반복 시리즈 전체가 아닌 특정 인스턴스만 삭제
- **부분적 변화**: 일부 인스턴스는 유지되어야 함
- **개수 변화**: 전체 개수에서 1개만 감소해야 함

## 검증 방법 비교

### 방법 1: 개수 기반 검증 (✅ 채택)
```typescript
// 삭제 전 이벤트 개수 확인
const beforeDeleteCount = eventList.getAllByText('반복 일정').length;

await user.click(deleteButton);

// 해당 인스턴스만 삭제되어 개수가 줄어들어야 함
await waitFor(() => {
  const afterDeleteCount = eventList.queryAllByText('반복 일정').length;
  expect(afterDeleteCount).toBe(beforeDeleteCount - 1);
});
```

**장점:**
- 정확한 변화량 측정 가능
- 부분 삭제 검증에 적합
- 다른 인스턴스 유지 확인 가능

### 방법 2: 존재/부재 검증 (❌ 부적절)
```typescript
// 전체 삭제 여부만 확인
expect(eventList.queryByText('반복 일정')).not.toBeInTheDocument();
```

**문제점:**
- 반복 일정의 개별 삭제에는 부적절
- 전체 삭제만 확인 가능
- 부분 삭제 검증 불가능

### 방법 3: 특정 ID 기반 검증 (❌ 복잡함)
```typescript
// 특정 인스턴스 ID로 확인
expect(eventList.queryByTestId('event-1-1')).not.toBeInTheDocument();
expect(eventList.queryByTestId('event-1-2')).toBeInTheDocument();
```

**문제점:**
- `data-testid` 의존성 (접근성 원칙 위배)
- 복잡한 ID 관리 필요
- 유지보수성 낮음

## 채택된 검증 전략 상세 분석

### 1단계: 삭제 전 상태 캡처
```typescript
const beforeDeleteCount = eventList.getAllByText('반복 일정').length;
```

**이유:**
- `getAllByText`: 모든 인스턴스 개수 정확히 측정
- 삭제 전 기준값 설정
- 반복 일정이 존재함을 확인

### 2단계: 삭제 작업 수행
```typescript
const firstEventItem = eventList.getAllByText('반복 일정')[0].closest('[role="article"]');
const deleteButton = within(firstEventItem as HTMLElement).getByLabelText('Delete event');
await user.click(deleteButton);
```

**주의사항:**
- 첫 번째 인스턴스를 일관되게 선택
- 스코프 제한으로 정확한 버튼 클릭
- 비동기 작업임을 고려

### 3단계: 삭제 후 상태 검증
```typescript
await waitFor(() => {
  const afterDeleteCount = eventList.queryAllByText('반복 일정').length;
  expect(afterDeleteCount).toBe(beforeDeleteCount - 1);
});
```

**핵심 포인트:**
- `queryAllByText`: 요소가 없을 수도 있으므로 `query` 사용
- `waitFor`: 비동기 DOM 업데이트 대기
- 정확히 1개 감소 확인

## 비동기 처리의 중요성

### waitFor 사용 이유
```typescript
// ❌ 동기적 검증 (실패 가능성)
const afterDeleteCount = eventList.queryAllByText('반복 일정').length;
expect(afterDeleteCount).toBe(beforeDeleteCount - 1);

// ✅ 비동기 검증 (안정적)
await waitFor(() => {
  const afterDeleteCount = eventList.queryAllByText('반복 일정').length;
  expect(afterDeleteCount).toBe(beforeDeleteCount - 1);
});
```

**필요성:**
- DELETE API 호출이 비동기
- DOM 업데이트 시간 필요
- React 상태 변경 반영 대기

## Edge Case 처리

### 1. 마지막 인스턴스 삭제
```typescript
if (beforeDeleteCount === 1) {
  // 마지막 인스턴스 삭제 시
  await waitFor(() => {
    expect(eventList.queryByText('반복 일정')).not.toBeInTheDocument();
  });
} else {
  // 일반적인 개별 삭제
  await waitFor(() => {
    const afterDeleteCount = eventList.queryAllByText('반복 일정').length;
    expect(afterDeleteCount).toBe(beforeDeleteCount - 1);
  });
}
```

### 2. 삭제 실패 시나리오
```typescript
// API 에러 시뮬레이션
server.use(
  http.delete('/api/events/:id', () => {
    return new HttpResponse(null, { status: 500 });
  })
);

// 삭제 실패 시 개수 유지 확인
await waitFor(() => {
  const afterDeleteCount = eventList.queryAllByText('반복 일정').length;
  expect(afterDeleteCount).toBe(beforeDeleteCount);
});
```

## 다른 기능과의 검증 전략 비교

### 단일 수정 vs 단일 삭제
```typescript
// 단일 수정: 아이콘 변화 확인
expect(updatedItem.queryByLabelText('반복 일정')).not.toBeInTheDocument();

// 단일 삭제: 개수 변화 확인  
expect(afterDeleteCount).toBe(beforeDeleteCount - 1);
```

### 전체 삭제 vs 개별 삭제
```typescript
// 전체 삭제: 완전 제거 확인
expect(eventList.queryByText('반복 일정')).not.toBeInTheDocument();

// 개별 삭제: 부분 제거 확인
expect(afterDeleteCount).toBe(beforeDeleteCount - 1);
```

## 핵심 교훈

### 1. **기능 특성에 맞는 검증 방법 선택**
- 전체 vs 부분 변화에 따른 검증 전략 차별화
- 반복 일정의 특수성 고려

### 2. **정확한 상태 측정**
- `getAllBy` → `queryAllBy` 단계별 사용
- 삭제 전후 정확한 개수 비교

### 3. **비동기 처리 필수**
- DELETE 작업의 비동기성 고려
- `waitFor`로 안정적인 검증

### 4. **Edge Case 고려**
- 마지막 인스턴스 삭제
- API 에러 상황
- 예외적 상황에 대한 대응

### 5. **접근성 우선 쿼리 유지**
- `data-testid` 대신 의미 있는 텍스트 기반 검증
- 사용자 관점의 검증 방법

이 검증 전략을 통해 반복 일정의 개별 삭제가 정확히 동작하는지 안정적으로 확인할 수 있게 되었습니다.
